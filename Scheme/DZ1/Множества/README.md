
Реализуйте библиотеку процедур для работы со множествами (для ханения множеств используйте списки):

-   Процедуру  _**(list->set xs)**_, преобразующую список  _xs_  в множество.
-   Предикат  _**(set? xs)**_, проверяющий, является ли список  _xs_  множеством.
-   Процедуру  _**(union xs ys)**_, возвращающую объединение множеств  _xs_  и  _ys_.
-   Процедуру  _**(intersection xs ys)**_, возвращающую пересечение множеств  _xs_  и  _ys_.
-   Процедуру  _**(difference xs ys)**_, возвращающую разность множеств  _xs_  и  _ys_.
-   Процедуру  _**(symmetric-difference xs ys)**_, возвращающую симметричную разность множеств  _xs_  и  _ys_.
-   Предикат  _**(set-eq? xs ys)**_, проверяющий множества  _xs_  и  _ys_  на равенство друг другу.

Примеры вызова процедур (порядок элементов множества не существенен):

> (list->set '(1 1 2 3))                       ⇒ (3 2 1)    
> (set? '(1 2 3))  ⇒ #t (set? '(1 2 3 3))       ⇒ #f   
> (set? '())    ⇒ #t    
> (union '(1 2 3) '(2 3 4))                    ⇒ (4 3 2 1)  
> (intersection '(1 2 3) '(2 3 4))             ⇒ (1 4 5)   
> (difference '(1 2 3 4 5) '(2 3))             ⇒ (2)   
> (symmetric-difference '(1 2 3 4) '(3 4 5 6)) ⇒ (6 5 2 1)   
> (set-eq? '(1 2 3) '(3 2 1))                  ⇒  #t   
> (set-eq? '(1 2) '(1 3))                      ⇒ #f  

Примечание. Так как порядок элементов множества может быть произвольным, при проверке сервер тестирования для проверки равенства множеств будет использовать определенный вами предикат  _set-eq?_. Примеры вызова процедур сервером тестирования:

> (set-eq? (list->set '(1 1 2 3))           '(1 2 3))               ⇒ #t  
> (set-eq? (union '(1 2 3) '(2 3 4))        '(4 3 2 1))             ⇒ #t  
> (set-eq? (intersection '(1 2 3) '(2 3 4)) '(3 2))                 ⇒ #t  
> (set-eq? (difference '(1 2 3 4 5) '(2 3)) '(1 4 5))               ⇒ #t  
> (set-eq? (difference '(2 3) '(3 4 5))     '(2))                   ⇒ #t  
> (set-eq? (symmetric-difference '(1 2 3 4) '(3 4 5 6)) '(6 5 2 1)) ⇒ #t  

